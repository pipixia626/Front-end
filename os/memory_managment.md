# 内存管理

## 背景

### 内存和寄存器

相同：
都是之间从CPU读取
一个是根据寄存器的名字
一个是根据地址空间

不同：
访问速度
寄存器>内存
寄存器（ 一个CPU时钟周期，内存2个以上）

两者速度不同产生了差异，降低了读取数据到CPU的效率

cache


### multistep processing of a  user program

.c->.obj->.exe/.dll 

### 逻辑地址和物理地址

逻辑地址：由CPU产生，等价于虚拟地址的存储空间

物理地址：实际可以从物理硬件上找到的存储位置

### MMU memory-management unit 地址映射

虚拟地址到物理地址的映射

用户程序只会使用到逻辑地址，在基址寄存器送入到内存的时候被加入到由一个用户进程锁产生的每个地址中

### 程序装载方式
绝对装入：在编译时就知道程序将放入内存中的那个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，
将程序和数据装入内存。绝对装入只适用于单道程序环境。

静态重定向：装入模块中的地址还是逻辑地址，直到真正装入时将逻辑地址变换位物理地址，程序运行期间无法移动

动态重定向：现代技术机基本都用这种技术。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，
而是把地址转换推迟到程序真正执行时才发生。这种方式需要一个重定位寄存器的支持。

居于局部性原理

#### 局部性原理
计算机存储结构采用层级存储
主存容量远远比缓存大，CPU执行程序的时候需要使用内存块，如果该内存块在缓存上，那么处理器直接从缓存上取该内存块就行了，
因为缓存的数据传输的速率比内存快的多。因为主存容量大，所以要取的内存块很可能不在缓存上，因此就要把这个内存块移到缓存上
局部性原理就是解决这个问题：

时间局部性：程序有在一段时间内多次访问同一个数据块的倾向，这个写程序的都知道；

空间局部性：程序往往有访问一个聚集空间的数据块的倾向，参见数组的访问；

## swap

进程从磁盘上调入CPU和调出

swap in sawp out

## 连续地址空间分配

### 固定分区
分区大小一定，内存利用率不高，而且内部碎片比较多

### 动态分区
根据进程所需地址空间进行分配

分区的个数、位置和大小都随着进程而动态变化，非常灵活，避免了在不同分区中因分区大小不当造成的内部碎片，提高内存利用率

内存被划分得越来越碎->外部碎片

### 紧凑
解决上述问题

#### 动态分区算法


First fit
Best fit
Next fix
Wrost fix
## 分页

## 页表


## 分段





























