
# TCP/UDP

## 前言
网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，
传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道
## TCP/UDP 特点与区别

1：UDP是面向无连接的，面向报文的，没有拥塞控制的尽最大可能交付，支持一对一，一对多，多对多的通信

2：TCP是面向连接的，字节流的，提供可靠交付，全双工通信有拥塞控制，拥塞控制的点对点通信

## 首部格式
UDP
 16位源端口号  | 16位目的端口号 

 16位UDP长度   |  16位UDP校验和 
  
   |             32位数据              |
## TCP的三次握手和四次挥手

### TCP的三次握手（为什么三次）
1、第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

2、换个易于理解的视角来看为什么要 3 次握手。
客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。
### TCP的四次挥手（为什么四次）
服务器在客户端想关闭连接时，还有数据要传输，因此客户端需要多等待服务器端把数据传输完

### TIME_WAIT
客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。
这么做有两个理由：确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，
A 等待一段时间就是为了处理这种情况的发生。

等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。


## TCP长连接和短连接的区别
短连接：Client 向 Server 发送消息，Server 回应 Client，然后一次读写就完成了，这时候双方任何一个都可以发起 close 操作，
不过一般都是 Client 先发起 close 操作。短连接一般只会在 Client/Server 间传递一次读写操作。
短连接的优点：管理起来比较简单，建立存在的连接都是有用的连接，不需要额外的控制手段。

长连接：Client 与 Server 完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。
在长连接的应用场景下，Client 端一般不会主动关闭它们之间的连接，Client 与 Server 之间的连接如果一直不关闭的话，
随着客户端连接越来越多，Server 压力也越来越大，这时候 Server 端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，
这样可以避免一些恶意连接导致 Server 端服务受损；如果条件再允许可以以客户端为颗粒度，限制每个客户端的最大长连接数，
从而避免某个客户端连累后端的服务。


## TCP粘包、拆包及解决办法
### 背景
假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到字节数是不确定的，

故可能存在以下四种情况：
服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包

服务端一次接受到了两个数据包，D1和D2粘合在一起，称之为TCP粘包

服务端分两次读取到了数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这称之为TCP拆包服务端分两次读取到了数据包，

第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余部分内容D1_2和完整的D2包。

特别要注意的是，如果TCP的接受滑窗非常小，而数据包D1和D2比较大，很有可能会发生第五种情况，即服务端分多次才能将D1和D2包完全接受，期间发生多次拆包。

### 粘包，拆包产生原因
1：滑动窗口
粘包：假设发送方的每256 bytes表示一个完整的报文，接收方由于数据处理不及时，这256个字节的数据都会被缓存到SO_RCVBUF(接收缓存区）中。
如果接收方的SO_RCVBUF中缓存了多个报文，那么对于接收方而言，这就是粘包。

拆包：考虑另外一种情况，假设接收方的窗口只剩了128，意味着发送方最多还可以发送128字节，而由于发送方的数据大小是256字节，因此只能发送前128字节，等到接收方ack后，才能发送剩余字节。这就造成了拆包。
2：MSS/MTU限制

MSS: Maximum Segement Size 标识TCP报文中data部分的最大长度，是TCP协议在OSI中传输层一次可以发送的最大的数据的限制

MTU：Mxitum Transmission unit 链路层一次可以发送的最大数据的限制
MSS是根据MTU计算处理的，当需要传输的数据大于MSS或者MTU时，数据会被拆分成多个包进行传输。由于MSS是根据MTU计算出来的

3：Nagle算法
为了尽可能发送大块数据，避免网络中充斥着许多小数据块
## TCP心跳包
### 设计目的
自身有长时间没有数据包情况下的判断连接是否还存在的检查，清除死连接，以及长连接的保活

### TCP的socket本身就是长连接，为什么还需要心跳包
1. 内网机器如果不主动向外发起连接，外网机没法直接连接内网的，这也是内网机安全的原因之一，又因为路由器会把这个关系记录下来，但是过一段时间这个纪录可能会丢失，所以每一个客户端每个一定时间就会向服务器发送消息，以确保服务器可以随时找到你，这个东西被称为心跳包
2. 理论上说，这个连接事一直保持连接的，但实际情况中，如果中间出现什么情况是难以想象的。更要命的是，有的节点（防火墙）会自动把一定时间之内没有数据交互的连接给断掉。这个时候我们就需要心跳包了，用于维持长连接，保活。

keepalve 是从socket error 获知连接断开的，是被动断开的
## TCP可靠传输
TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。
## TCP滑动窗口
窗口是缓存的一部分，用来暂时存放字节流，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

## 可靠的传输机制
捎带确认:接收方在会给发送方发送一个确认帧来告诉发送方收到了
超时重传:在发送某个数据帧之后，就开启一个计时器，开始计时，一旦超过某段时间还没有收到确认帧，就重新发送该数据帧

### 停等协议
发送窗口和接受窗口大小都是1
### 回退N协议

#### 解决问题
过长的往返时间严重影响带宽的利用率
#### 原理
发送窗口的大小>1，接收窗口的大小=1
接收端发现某一帧发生差错时，直接丢弃所有后续的帧，对丢弃帧不发送确认
数据链路层除了接收应该递交给网络层的下一帧之外，拒绝接收其它任何帧
发送方最终会超时，将按顺序重传所有未被确认的帧，即从最初受损或丢失的那一帧开始
接收端接收帧的顺序和发送端发出帧的顺序相同

#### 使用情况
回退n帧协议，如果错误率较低时，工作的很好
但错误率较高时，就会浪费大量的带宽在重传上

### 选择重传
接收方的数据链路层存储坏帧之后的所有正确的帧，当发送方得知某个帧出错时，只是重传此坏帧，而不是所有的后继帧
## TCP流量控制

## TCP拥塞控制

## 提高网络利用率
流量控制和拥塞控制
针对不同业务采用不同协议
## UDP如何实现可靠传输
在应用层模仿传输层TCP的可靠传输

1、添加seq/ack机制，确保数据发送到对端
2、添加发送和接收缓冲区，主要是用户超时重传。
3、添加超时重传机制。
